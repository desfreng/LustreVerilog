node xor (x, y: r<1>) returns (out: r<1>);
  let
    out = (x or y) and not (x and y);
  tel

node fullAdder1 (a, b, carryIn: r<1>)
  returns (res, carryOut: r<1>);   
  var
    a_and_b, a_and_carryIn, b_and_carryIn: r<1>;
  let
    a_and_b = a and b;
    a_and_carryIn = a and carryIn;
    b_and_carryIn = b and carryIn;
    res = xor (xor (a, b), carryIn);
    carryOut = a_and_b or a_and_carryIn or b_and_carryIn;
  tel

node fullAdder (x: r<N>; y: r<N>; cIn: r<1>) returns (res: r<N>; carryOut: r<1>);
  size N;
  where
    N > 0;
  when N <= 1:
    let
      (res, carryOut) = fullAdder1 (x, y, cIn);
    tel
  otherwise
    var
      loRes: r<N-1>;
      loCarry, hiRes: r<1>;
    let
      (loRes, loCarry) = fullAdder (x[0:N-1], y[0:N-1], cIn);
      (hiRes, carryOut) = fullAdder1 (x[N-1:N], y[N-1:N], loCarry);
      res = hiRes ++ loRes;
    tel

node main(x: r<8>; y: r<8>) returns (isGood: bool);
  var
    cOut: bool;
    res: r<8>;
let
  (res, cOut) = fullAdder(x, y, 0);
  isGood = unsigned res == unsigned x + unsigned y;
tel

